---
title: Arrays and Slices
description: Learn about fixed-size arrays and dynamic slices in sr-lang.
template: doc
order: 5
---

## Arrays and Slices

sr-lang provides two fundamental data structures for working with sequences of elements: **arrays** and **slices**.

### Arrays

An **array** is a collection of elements of the same type, stored contiguously in memory, with a **fixed size** that is known at compile time. Because their size is fixed, arrays are allocated on the stack, making them very efficient.

#### Defining Arrays

You define an array by specifying its size and element type, followed by the initial values.

```go
// An array of 3 integers
arr: [3]i32 = [1, 2, 3];

// Access elements by index
printf("Array: %d, %d, %d\n", arr[0], arr[1], arr[2]);
```

**Output:**
```
Array: 1, 2, 3
```

Arrays are mutable, meaning you can change the value of their elements.

```go
arr: [3]i32 = [10, 20, 30];
arr[1] = 25; // Modify the element at index 1
printf("Modified array: %d, %d, %d\n", arr[0], arr[1], arr[2]);
```

**Output:**
```
Modified array: 10, 25, 30
```

You can also create multi-dimensional arrays.

```go
// A 2x2 matrix
matrix: [2][2]i32 = [[1, 2], [3, 4]];
printf("Matrix[0][1]=%d\n", matrix[0][1]);
```

**Output:**
```
Matrix[0][1]=2
```

### Slices

A **slice** is a dynamically-sized, flexible view into a portion of an array. A slice does not own its data; it **borrows** it from an array. A slice is a small object that contains two pieces of information: a pointer to the first element of the slice and the length of the slice.

#### Creating Slices

You create a slice from an existing array using a range expression `[start..end]`. The range is half-open, meaning it includes the element at `start` but excludes the element at `end`.

```go
arr := [1, 2, 3, 4, 5];

// Create a slice that contains the elements at index 1, 2, and 3
slice := arr[1..4]; // Contains [2, 3, 4]

printf("Slice: %d, %d, %d\n", slice[0], slice[1], slice[2]);
printf("Slice length: %d\n", slice.len);
```

**Output:**
```
Slice: 2, 3, 4
Slice length: 3
```

#### Slices are Views

Because a slice is just a view into an underlying array, modifying the elements of a slice will modify the original array.

```go
arr := [1, 2, 3, 4, 5];
slice := arr[1..4];

// Modify the first element of the slice
slice[0] = 99;

// The original array is changed
printf("Array after slice modification: %d, %d, %d, %d, %d\n",
  arr[0], arr[1], arr[2], arr[3], arr[4]
);
```

**Output:**
```
Array after slice modification: 1, 99, 3, 4, 5
```

This makes slices a powerful and efficient way to pass sequences of data to functions without needing to copy the data.

```go
process_slice :: proc(s: []i32) {
  printf("Slice elements: %d, %d\n", s[0], s[1]);
}

arr := [10, 20, 30, 40];
// Pass a slice of the array to the function
process_slice(arr[1..3]);
```

**Output:**
```
Slice elements: 20, 30
```